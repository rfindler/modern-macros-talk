\documentclass[runningheads]{llncs}
\usepackage[T1]{fontenc}
\usepackage{pslatex}
\usepackage{cutwin}
\cutfuzz
\usepackage{graphicx}
\usepackage{color}
\usepackage{hyperref}
\begin{document}
\clubpenalty=150  %% this cancels \clubpenalty=10000 in llncs.cls and also makes the shaped cut out work
\title{Language-oriented Programming in Racket: Embodying 60 Years of Work on Macros\\in an Extensible Compiler Front-end}
\author{Robert Bruce Findler\orcidID{0000-0002-4245-2000}}
\authorrunning{Robert Bruce Findler}
\institute{Northwestern University, Evanston IL 60208, USA\\
\email{robby@northwestern.edu}\\
\url{https://users.cs.northwestern.edu/~robby/}
}
%
\maketitle              % typeset the header of the contribution

\newcommand*{\mycut}{%
        0.2\textwidth, 0.4\textwidth,
        0.2\textwidth, 0.4\textwidth
}


%\renewcommand*{\putstuffinpic}{%
%  \put(0,-8){\makebox(0,0){\includegraphics[scale=.5]{racket-logo.eps}}}}

Racket's approach to language-oriented programming facilitates and
simplifies the implementation of programming languages by providing an
extensible and flexible compiler front end. This front end is, in
truth, a sophisticated macro system that traces its roots back to the
mid 1950s. In those days, macros were mere text-based preprocessors,
divorced from the programming language they operated on (a tradition
that continues only slightly changed today in some programming
languages, alas). In the intervening years, macros have matured and
become a full-fledged part of the programming language itself, making
them far more powerful and general.

In order to explain the power and generality that such a macro system
brings, this tail will focus on three central aspects of Racket's
macro system design:
\begin{itemize}

\item \textbf{the data structure for abstract syntax trees} and how it
  manages identifiers, avoiding accidental clashes;

\item \textbf{the minimal barrier between ``object'' and ``subject''
  languages}, meaning that as soon as a new language is defined it
  is easily used to build the next language;

\item \textbf{the way a set of macros are distributed in separate
  files and yet together form a single compiler}, which allows one
  language to reuse parts of another language, even when the two
  languages are more different than alike.
\end{itemize}

All three of these design aspects are deeply connected to scope, a
theme that permeates the talk. Racket's sophisticated handling of
scope even goes beyond language definition, enabling reuse for
developer tools like the compilation manager, the debugger, and the
IDE. The talk will draw these connections and show how they point the
way for future work to automatically or nearly automatically provide
sophisticated tool support for programmers writing code in
Racket-based languages.

\end{document}
