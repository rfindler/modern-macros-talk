# Random notes

## an open compiler: how to make the case?

What is a compiler?
  -- translates from one language to another
  -- what does it mean to be "open"?

  -- split out the cases of the compiler into separate functions,
     mix and match the functions
      --> macros and module systems

  -- but what about accumulator?
      --> syntax-local-value

  -- what is the AST data structure?

missing idea: avoiding the need for a separation between object and
subject languages. Collapse the layers!

is "open compiler" really the right phrase? Is this something more?

---- looking forward, there are problems:

  ---> what if the fixed way the expander recurs is not right for you?
       Maybe you wanted to have a sublanguage with its own macro
       system?  Ballantyne to the rescue!

  ---> we need to do better with the IDE; how can we build on the
       understanding of scope to get more refactoring tools?

-----------------------------

easily take apart and reuse the front-end of a compiler -> lots of languages with interesting semantics
  -- demonstrate the breadth of languages

Thinking of Racket as a programming language factory, would you say that these three aspects of it are the essential ones that allow us to build languages with good reuse and minimal effort? (Am I missing one or is one wrong?)

1) the module system: this is how we actually reuse existing compilers-- each compiler comes to us as sets of cases (the individual exports of a module) that we can mix and match putting together into a new compiler.

2) syntax-object data structure: this is the AST; clearly we need something here and it needs to be good :)

3) the fact that there is only a very thin barrier between the "object" and "subject" languages of each of the compilers for each language. We need _some_ barrier so that we can compile a program and throw away everything but the output of the compiler (so we can save compiled files and do dependency management at the library level) but we want to quickly grow a language, using one language to implement the next one and the next one and the next one without much friction.

on 3, Matthew writes "That sounds right to me. I might phrase (3) as some combination of “thin” and “gradual”, aiming for a smooth path between libraries and languages".

On 3: One thing that comes to mind is bootstrapping -- specifically that we don't do it, even though %#kernel is a pretty impoverished language. So being able to easily turn around and use a language as soon as you have improved it even just slightly is important.


-----------------------------

.... introduce idea: open compiler. What does this mean?
  -- mix and match "cases" of the compiler.
     show a recursive function that gets broken apart with the
     cases distributed and the recursive iteration step broken out.

.... just how far can you go with an open compiler front end? Isn't
     the back end where the good stuff happens?

     demo some languages

.... bring in key elements

syntax-object data structure:
  show how it keeps binding/bound information; sets of scopes

expander algorithm:
  works from the outside in

module system:
  manages dependencies between code
   -- once a program is fully expanded, we can load it without the
      dependencies needed for compilation (this can be a big deal; show picture?)

  submodules ---- generated by macros!

one thing got lost: the accumulator argument (where to bring this in?)
  show how we get it back.

.... explain how they work together to define a language

an example that illustrates the power

.... into the IDE(?)